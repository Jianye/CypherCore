/*
 * Copyright (C) 2012-2013 CypherCore <http://github.com/organizations/CypherCore>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */﻿

using Framework.Constants;
using Framework.Network;
using WorldServer.Game.Managers;
using WorldServer.Network;
using WorldServer.Game.WorldEntities;
using Framework.Logging;
using System.Collections.Generic;
using Framework.ObjectDefines;

namespace WorldServer.Game.Packets
{
    public class ItemHandler : Cypher
    {
        [ClientOpcode(Opcodes.CMSG_SwapInvItem)]
        public static void HandleSwapInvenotryItem(ref PacketReader packet, ref WorldSession session)
        {
            byte dstslot = packet.ReadByte();
            byte srcslot = packet.ReadByte();

            var pl = session.GetPlayer();

            // prevent attempt swap same item to current position generated by client at special checting sequence
            if (srcslot == dstslot)
                return;

            if (!pl.IsValidPos(InventorySlots.Bag0, srcslot, true))
            {
                pl.SendEquipError(InventoryResult.ItemNotFound, null);
                return;
            }

            if (!pl.IsValidPos(InventorySlots.Bag0, dstslot, true))
            {
                pl.SendEquipError(InventoryResult.WrongSlot, null);
                return;
            }

            ushort src = (ushort)((uint)(InventorySlots.Bag0 << 8) | srcslot);
            ushort dst = (ushort)((uint)(InventorySlots.Bag0 << 8) | dstslot);

            pl.SwapItem(src, dst);
        }

        [ClientOpcode(Opcodes.CMSG_SwapItem)]
        public static void HandleSwapItem(ref PacketReader packet, ref WorldSession session)
        {
            byte dstbag = packet.ReadByte();
            byte dstslot = packet.ReadByte();
            byte srcbag = packet.ReadByte();
            byte srcslot = packet.ReadByte();

            ushort src = (ushort)((srcbag << 8) | srcslot);
            ushort dst = (ushort)((dstbag << 8) | dstslot);

            var pl = session.GetPlayer();

            // prevent attempt swap same item to current position generated by client at special checting sequence
            if (src == dst)
                return;

            if (!pl.IsValidPos(srcbag, srcslot, true))
            {
                pl.SendEquipError(InventoryResult.ItemNotFound, null);
                return;
            }

            if (!pl.IsValidPos(dstbag, dstslot, true))
            {
                pl.SendEquipError(InventoryResult.WrongSlot, null);
                return;
            }

            pl.SwapItem(src, dst);
        }

        [ClientOpcode(Opcodes.CMSG_AutoequipItemSlot)]
        public static void HandleAutoEquipItemSlot(ref PacketReader packet, ref WorldSession session)
        {
            ulong itemguid = packet.ReadUInt64();
            byte dstslot = packet.ReadByte();
            
            var pl = session.GetPlayer();

            // cheating attempt, client should never send opcode in that case
            if (!pl.IsEquipmentPos(InventorySlots.Bag0, dstslot))
                return;
            
            Item item = pl.GetItemByGuid(itemguid);
            ushort dstpos = (ushort)(dstslot | (InventorySlots.Bag0 << 8));
            
            if (item == null || item.GetPos() == dstpos)
                return;

            pl.SwapItem(item.GetPos(), dstpos);
        }

        [ClientOpcode(Opcodes.CMSG_AutoequipItem)]
        public static void HandleAutoEquipItemOpcode(ref PacketReader packet, ref WorldSession session)
        {
            byte srcbag = packet.ReadByte();
            byte srcslot = packet.ReadByte();

            var pl = session.GetPlayer();

            Item pSrcItem = pl.GetItemByPos(srcbag, srcslot);
            if (pSrcItem == null)
                return;                                             // only at cheat

            ushort dest;
            InventoryResult msg = pl.CanEquipItem(ItemConst.NullSlot, out dest, pSrcItem, !pSrcItem.IsBag());
            if (msg != InventoryResult.Ok)
            {
                pl.SendEquipError(msg, pSrcItem, null);
                return;
            }

            ushort src = pSrcItem.GetPos();
            if (dest == src)                                           // prevent equip in same slot, only at cheat
                return;

            Item pDstItem = pl.GetItemByPos(dest);
            if (pDstItem == null)                                         // empty slot, simple case
            {
                pl.RemoveItem(srcbag, srcslot, true);
                pl.EquipItem(dest, pSrcItem, true);
                //pl.AutoUnequipOffhandIfNeed();
            }
            else                                                    // have currently equipped item, not simple case
            {
                byte dstbag = pDstItem.GetBagSlot();
                byte dstslot = pDstItem.GetSlot();

                msg = pl.CanUnequipItem(dest, !pSrcItem.IsBag());
                if (msg != InventoryResult.Ok)
                {
                    pl.SendEquipError(msg, pDstItem, null);
                    return;
                }

                // check dest->src move possibility
                List<ItemPosCount> sSrc = new List<ItemPosCount>();
                ushort eSrc = 0;
                if (pl.IsInventoryPos(src))
                {
                    msg = pl.CanStoreItem(srcbag, srcslot, ref sSrc, pDstItem, true);
                    if (msg != InventoryResult.Ok)
                        msg = pl.CanStoreItem(srcbag, ItemConst.NullSlot, ref sSrc, pDstItem, true);
                    if (msg != InventoryResult.Ok)
                        msg = pl.CanStoreItem(ItemConst.NullBag, ItemConst.NullSlot, ref sSrc, pDstItem, true);
                }
                else if (pl.IsBankPos(src))
                {
                    msg = pl.CanBankItem(srcbag, srcslot, ref sSrc, pDstItem, true);
                    if (msg != InventoryResult.Ok)
                        msg = pl.CanBankItem(srcbag, ItemConst.NullSlot, ref sSrc, pDstItem, true);
                    if (msg != InventoryResult.Ok)
                        msg = pl.CanBankItem(ItemConst.NullBag, ItemConst.NullSlot, ref sSrc, pDstItem, true);
                }
                else if (pl.IsEquipmentPos(src))
                {
                    msg = pl.CanEquipItem(srcslot, out eSrc, pDstItem, true);
                    if (msg == InventoryResult.Ok)
                        msg = pl.CanUnequipItem(eSrc, true);
                }

                if (msg != InventoryResult.Ok)
                {
                    pl.SendEquipError(msg, pDstItem, pSrcItem);
                    return;
                }

                // now do moves, remove...
                pl.RemoveItem(dstbag, dstslot, false);
                pl.RemoveItem(srcbag, srcslot, false);

                // add to dest
                pl.EquipItem(dest, pSrcItem, true);

                // add to src
                if (pl.IsInventoryPos(src))
                    pl.StoreItem(sSrc, pDstItem, true);
                else if (pl.IsBankPos(src))
                    pl.BankItem(sSrc, pDstItem, true);
                else if (pl.IsEquipmentPos(src))
                    pl.EquipItem(eSrc, pDstItem, true);

                pl.AutoUnequipOffhandIfNeed();
            }
        }

        [ClientOpcode(Opcodes.CMSG_BuyItem)]
        public static void HandleBuyItem(ref PacketReader packet, ref WorldSession session)
        {
            Log.outDebug("WORLD: Received CMSG_BUY_ITEM");
            ulong vendorguid = packet.ReadUInt64();
            ItemVendorType itemType = (ItemVendorType)packet.ReadUInt8(); // 1 = item, 2 = currency
            uint item = packet.ReadUInt32();
            uint slot = packet.ReadUInt32();
            uint count = packet.ReadUInt32();
            ulong bagGuid = packet.ReadUInt64();
            byte bagSlot = packet.ReadUInt8();

            // client expects count starting at 1, and we send vendorslot+1 to client already
            if (slot > 0)
                --slot;
            else
                return; // cheating

            Player pl = session.GetPlayer();

            if (itemType == ItemVendorType.Item)
            {
                Item bagItem = pl.GetItemByGuid(bagGuid);

                byte bag = ItemConst.NullBag;
                if (bagItem != null && bagItem.IsBag())
                    bag = bagItem.GetSlot();

                pl.BuyItemFromVendorSlot(vendorguid, slot, item, (byte)count, bag, bagSlot);
            }
            //else if (itemType == ItemVendorType.Currency)
                //pl.BuyCurrencyFromVendorSlot(vendorguid, slot, item, count);
            else
                Log.outDebug("WORLD: received wrong itemType ({0} in HandleBuyItemOpcode", itemType);
        }

        [ClientOpcode(Opcodes.CMSG_SellItem)]
        public static void HandleSellItemOpcode(ref PacketReader packet, ref WorldSession session)
        {
            Log.outDebug("WORLD: Received CMSG_SELL_ITEM");
            ulong vendorguid = packet.ReadUInt64();
            ulong itemguid = packet.ReadUInt64();
            uint count = packet.ReadUInt32();

            if (itemguid == 0)
                return;

            var pl = session.GetPlayer();

            Creature creature = pl.GetNPCIfCanInteractWith(vendorguid, NPCFlags.Vendor);
            if (creature == null)
            {
                Log.outDebug("WORLD: HandleSellItemOpcode - Unit (GUID: {0}) not found or you can not interact with him.", ObjectGuid.GuidLowPart(vendorguid));
                pl.SendSellError(SellResult.CantFindVendor, null, itemguid);
                return;
            }

            // remove fake death
            //if (pl.HasUnitState(UNIT_STATE_DIED))
            //GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

            Item pItem = pl.GetItemByGuid(itemguid);
            if (pItem != null)
            {
                // prevent sell not owner item
                if (pl.GetGUID() != pItem.GetOwnerGUID())
                {
                    pl.SendSellError(SellResult.CantSellItem, creature, itemguid);
                    return;
                }

                // prevent sell non empty bag by drag-and-drop at vendor's item list
                if (pItem.IsNotEmptyBag())
                {
                    pl.SendSellError(SellResult.CantSellItem, creature, itemguid);
                    return;
                }

                // prevent sell currently looted item
                //if (pl.GetLootGUID() == pItem.GetGUID())
                {
                    //pl.SendSellError(SellResult.CantSellItem, creature, itemguid);
                    //return;
                }

                // prevent selling item for sellprice when the item is still refundable
                // this probably happens when right clicking a refundable item, the client sends both
                // CMSG_SELL_ITEM and CMSG_REFUND_ITEM (unverified)
                if (pItem.HasFlag(ItemFields.Flags, ItemFlags.Refundable))
                    return; // Therefore, no feedback to client

                // special case at auto sell (sell all)
                if (count == 0)
                {
                    count = pItem.GetStackCount();
                }
                else
                {
                    // prevent sell more items that exist in stack (possible only not from client)
                    if (count > pItem.GetStackCount())
                    {
                        pl.SendSellError(SellResult.CantSellItem, creature, itemguid);
                        return;
                    }
                }

                ItemTemplate pProto = pItem.GetTemplate();
                if (pProto != null)
                {
                    if (pProto.SellPrice > 0)
                    {
                        if (count < pItem.GetStackCount())               // need split items
                        {
                            Item pNewItem = pItem.CloneItem(count, pl);
                            if (pNewItem == null)
                            {
                                Log.outError("WORLD: HandleSellItemOpcode - could not create clone of item {0}; count = {1}", pItem.GetEntry(), count);
                                pl.SendSellError(SellResult.CantSellItem, creature, itemguid);
                                return;
                            }

                            pItem.SetStackCount(pItem.GetStackCount() - count);
                            //pl.ItemRemovedQuestCheck(pItem.GetEntry(), count);
                            if (pl.IsInWorld)
                                pItem.SendUpdateToPlayer(pl);
                            pItem.SetState(ItemUpdateState.Changed, pl);

                            pl.AddItemToBuyBackSlot(pNewItem);
                            if (pl.IsInWorld)
                                pNewItem.SendUpdateToPlayer(pl);
                        }
                        else
                        {
                            //pl.ItemRemovedQuestCheck(pItem.GetEntry(), pItem.GetStackCount());
                            pl.RemoveItem(pItem.GetBagSlot(), pItem.GetSlot(), true);
                            pItem.RemoveFromUpdateQueueOf(pl);
                            pl.AddItemToBuyBackSlot(pItem);
                        }

                        uint money = pProto.SellPrice * count;
                        pl.ModifyMoney(money);
                        //pl.UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_MONEY_FROM_VENDORS, money);
                    }
                    else
                        pl.SendSellError(SellResult.CantSellItem, creature, itemguid);
                    return;
                }
            }
            pl.SendSellError(SellResult.CantSellItem, creature, itemguid);
            return;
        }
    }
}
